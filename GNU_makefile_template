#g++ compiler: options

# -std=c++0x enables ISO C++ 11 standard ,确定C++ 11标准
# -I.. pulls in the Version_test.h file for conditional compilation
#      of code the uses features that might not yet be implemented
CC = g++
CCFLAGS = -std=c++0x -I..

# Some programs include headers defined in earlier chapters
# LOCFLAGS used to set tell the compiler where to find a
# header that is not in the same directory as the source file itself
# LOCFLAGS will be set in directory level makefiles as needed
# LOCFLAGS 指定gcc编译的include 路径
LOCFLAGS = -I$(ROOT)/include


### 编译输出bin可执行文件的目录
BINPATH = $(ROOT)/bin

### 编译输出.o 的lib
LINKPATH = $(ROOT)/lib

####### To compile without using a makefile
# To compile an object file from a source file you could execute
# g++ -std=c++0x -c filename.cc # produces filename.obj
# To compile an executable file from an object file, you would execute
# g++ -std=c++0x filename.o      # produces filename.exe
# To compile an executable file from a source file, you would execute
# g++ -std=c++0x filename.cc    # produces filename.exe
#######

# each subdirectory contains a Makefile that lists the executable
# files that can be made in that directory.  That list is assigned
# to the make macro named $OBJECTS
# This rule says that the make target named "all" depends on those
# files.  Executing "make all" in a subdirectory will cause make
# to build each .exe file listed in that subdirectory's makefile
all: $(OBJECTS) 

# rule that says how to make a .o object file from a .cc source file
# for a given source file in a given directory you could compile it
# into an object file by executing "make filename.o"

# $< and $@ are macros defined by make
#     $< refers to the file being processed (i.e., compiled or linked)
#     $@ refers to the generated file
%.o: %.cc 
	$(CC) $(CCFLAGS) $(LOCFLAGS) -c $< -o $(LINKPATH)/$@

# rule that says how to make a .exe executable file from a .o object file
# 对于所有的.bin 目标，将编译的.o依赖全部加上前缀路径，并且生成到$(BINPATH)目录下去
%.bin: %.o 
	$(CC) $(CCFLAGS) $(LOCFLAGS) $(addprefix $(LINKPATH)/, $^)  -o $(BINPATH)/$@
#	$(CC) $(CCFLAGS) $(LOCFLAGS) $< -o  $(BINPATH)/$@

# target to clean up the object files and any core files
# executing "make clean" in a subdirectory will remove all
# files named core or any file ending in .obj, or .stackdump
# 删除所有编译过程中生成的.o和.bin
clean:
	rm -rf $(LINKPATH)/*.o $(BINPATH)/*.bin

# target to remove executable files as well as object and core files
# clobber: clean
#	rm -rf *.bin 
